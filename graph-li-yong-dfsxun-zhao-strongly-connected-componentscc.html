<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">

        <link rel="shortcut icon" type="image/x-ico" href="http://alrightchiu.github.io/SecondRound/theme/images/favicon.ico" />


        <title>Graph: 利用DFS尋找Strongly Connected Component(SCC)</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Graph" />
        <meta name="tags" contents="DFS" />
        <meta name="tags" contents="DAG" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Second Round">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-strongly-connected-componentscc.html">
	<meta property="og:title" content="Graph: 利用DFS尋找Strongly Connected Component(SCC)">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2016-02-17 21:49:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Second Round</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Graph: 利用DFS尋找Strongly Connected Component(SCC)</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on  2 17, 2016
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h3>先備知識與注意事項</h3>
<p>在一個directed graph中，若對於任意兩個vertex(A)與vertex(B)之間，不是同時存在「從vertex(A)走到vertex(B)」以及「從vertex(B)走到vertex(A)」的path，那麼此directed graph就不是strongly connected，裡面一定包含了兩個以上的strongly connected component(SCC)。  </p>
<p>如圖一(a)，經由path:0-1-2-5，可以從vertex(0)走到vertex(5)，但是無論經過任何vertex，都沒有辦法從vertex(5)走到vertex(0)，因此，圖一(a)的directed graph並不是strongly connected，其中包含了兩個以上的SCC(答案是三個)。</p>
<p><center>
<img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f1.png?raw=true" /></p>
<p><strong>圖一(a)。</strong><br />
</center></p>
<p>那麼，要如何分辨一個directed graph中的strongly connected component(SCC)，並列出每一個SCC中的所有vertex呢？</p>
<p>本篇文章的目的就是要回應此問題。</p>
<p>演算法將會用到<strong>Transpose of Graph</strong>，如圖一(b)，把G中所有vertex維持不變，<strong>edge的方向顛倒</strong>，就得到G<sup>T</sup>，例如，原本的edge(0,1)改為edge(1,0)，edge(5,6)改為edge(6,5)。  </p>
<p><center>
<img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f2.png?raw=true" /></p>
<p><strong>圖一(b)。</strong><br />
</center></p>
<p>最重要的是：<strong>G與G<sup>T</sup>的SCC完全相同</strong>。  </p>
<p>原因在於，觀察G中包含在同一個SCC裡的vertex(2)與vertex(3)。G中同時存在「從vertex(2)走到vertex(3)」的path，以及「從vertex(3)走到vertex(2)」的path。在G進行「Transpose」得到G<sup>T</sup>後，這兩條path分別變成與原方向之相反方向，但是存在於vertex(2)與vertex(3)之間的<strong>cycle</strong>仍然存在。<br />
因此，在G裡面屬於同一個SCC的vertex，在G<sup>T</sup>裡將形成相同的SCC。 </p>
<p>最後一點溫馨小提醒：一如往常，本篇文章將不會有嚴謹證明，不過在<a href="#ref">參考資料</a>會附上內有嚴謹證明的網站連結，請讀者務必前往一窺究竟。</p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#if_dfs_only">如果只有一次DFS不行嗎？</a></li>
<li><a href="#algorithm">演算法</a></li>
<li><a href="#code">程式碼</a></li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#series">BFS/DFS系列文章</a></li>
</ul>
<p></br></p>
<p><a name="if_dfs_only"></a></p>
<h2>如果只有一次DFS不行嗎？</h2>
<p>在<a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html">上一篇文章</a>提到，只用一次<code>DFS()</code>或<code>BFS()</code>得到<code>predecessor</code>後，便能夠找到undirected graph中的connected component。</p>
<p>那如果用來找SCC？</p>
<p>以下示範兩次<code>DFS()</code>來說明，一次是按照「<span class="math">\(8、7、...、2、1\)</span>」之順序把vertex設為搜尋起點，另一次則是按照「<span class="math">\(1、2、...、7、8\)</span>」之順序。</p>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f3.png?raw=true" /></p>
<p><strong>圖二(a)：以vertex(8)作為起點，接著是vertex(5)、vertex(3)。</strong>
</center></p>
<p>圖二(a)，首先以vertex(8)作為<code>DFS()</code>的第一次起點，在搜尋完以vertex(8)作為<code>root</code>的Depth-First Tree後，再以vertex(5)作為新的起點。同樣的，在搜尋完以vertex(5)作為<code>root</code>的Depth-First Tree後，再以vertex(3)作為新的起點。<br />
從圖二(a)的「時間軸」可以看出，此次<code>DFS()</code>找到了一個Depth-First Forest，其中包含三棵Depth-First Tree，而這三棵Depth-First Tree分別就是Graph中的三個SCC。</p>
<p>問題不就解決了嗎？<br />
透過一次<code>DFS()</code>就找到了directed graph中的SCC。</p>
<p>再接著看圖二(b)，以vertex(0)作為<code>DFS()</code>的起點。<br />
很遺憾，「時間軸」裡形成了一整棵Depth-First Tree，directed graph中的三個SCC沒有被分開。</p>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f4.png?raw=true" /></p>
<p><strong>圖二(b)：以vertex(0)作為起點。</strong><br />
</center></p>
<p>由於SCC需要兩個方向的path(「vertex(X)到vertex(Y)」和「vertex(Y)到vertex(X)」)都成立，但是<code>DFS()</code>只在意「單方向」的edge，只要存在edge(X,Y)，便把<code>predecessor[Y]</code>更新成vertex(X)，在Predecessor Subgraph裡，vertex(X)與vertex(Y)便在同一棵Depth-First Tree中。  </p>
<p>因此，只有一次<code>DFS()</code>的<code>predecessor</code>是不夠的，圖二(a)只是運氣好。</p>
<p></br>
以下便開始本次的「拒絕運氣好大作戰」。<br />
</br></p>
<p><a name="algorithm"></a></p>
<h2><strong>演算法</strong></h2>
<p>若考慮具有多個SCC的directed graph，為了方便起見，定義其<strong>Component Graph</strong>為<span class="math">\(G^{SCC}=(V^{SCC},E^{SCC})\)</span>，其中：</p>
<ul>
<li><span class="math">\(V^{SCC}\)</span>：把每個SCC視為一個元素，並以該元素作為<span class="math">\(V^{SCC}\)</span>的vertex。<ul>
<li>例如圖三(a)，令<span class="math">\(C_1=\)</span>{<span class="math">\(0,1,2,3\)</span>}，<span class="math">\(C_2=\)</span>{<span class="math">\(4,5\)</span>}，<span class="math">\(C_3=\)</span>{<span class="math">\(6,7,8\)</span>}，則<span class="math">\(V^{SCC}=\)</span>{<span class="math">\(C_1,C_2,C_3\)</span>}。</li>
</ul>
</li>
<li><span class="math">\(E^{SCC}\)</span>：考慮vertex(X)屬於<span class="math">\(C_1\)</span>，vertex(Y)屬於<span class="math">\(C_2\)</span>，若存在「連結兩個不同SCC」的edge(X,Y)，則edge(X,Y)便屬於<span class="math">\(E^{SCC}\)</span>。<ul>
<li>以圖三(a)為例，vertex(1)屬於<span class="math">\(C_1\)</span>，vertex(4)屬於<span class="math">\(C_2\)</span>，則edge(1,4)屬於<span class="math">\(E^{SCC}\)</span>，依此類推，便得到<span class="math">\(E^{SCC}=\)</span>{<span class="math">\((1,4),(2,5),(4,6),(5,6),(5,7)\)</span>}。</li>
</ul>
</li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f5.png?raw=true" /></p>
<p><strong>圖三(a)：每一個directed graph，只要「以SCC作為基本元素(vertex)」，都會有其相對應的component graph。</strong><br />
</center></p>
<p>由上述定義可以觀察出，每一個directed graph，只要「以SCC作為基本元素(vertex)」，都會有其相對應的component graph。</p>
<p>而使用component graph的優點是：「component graph一定是<strong>directed acyclic graph(DAG)</strong>」。  </p>
<ul>
<li>因為SCC的定義<a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html">(請參閱：Graph: Intro(簡介))</a>，若C<sub>1</sub>與C<sub>2</sub>之前存在<strong>cycle</strong>，那就表示C<sub>1</sub>和C<sub>2</sub>都不應該自稱為SCC，而要合併C<sub>1</sub>與C<sub>2</sub>成為一個更大集合的SCC。因此，不同的SCC之間，一定不存在<strong>cycle</strong>。  </li>
<li>等價的性質：若directed graph中存在兩個SCC，分別為C<sub>1</sub>與C<sub>2</sub>，若存在一條path從C<sub>1</sub>中的vertex(X)走到C<sub>2</sub>中的vertex(Y)，就不可能同時存在一條path從C<sub>2</sub>中的vertex(Z)走到C<sub>1</sub>中的vertex(W)，否則即出現<strong>cycle</strong>，應該合併成更大的SCC(C<sub>3</sub>)，如圖三(b)。</li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f6.png?raw=true" /></p>
<p><strong>圖三(b)：SCC。</strong><br />
</center></p>
<p>考慮如圖三(c)的DAG(directed acyclic graph)，若<code>DFS()</code>在每次尋找「新的搜尋起點時」，能夠按照「一條path上，從尾端至開頭」的vertex順序，那麼<strong>Predecessor Subgraph</strong>就能長成「能夠分辨出SCC」的<strong>Depth-First Forest</strong>。</p>
<ul>
<li>圖三(c)中，由於從C<sub>3</sub>無法往回走到C<sub>2</sub>，從C<sub>2</sub>無法往回走到C<sub>1</sub>，因此，<code>DFS()</code>的起點順序若為：C<sub>3</sub>、C<sub>2</sub>、C<sub>1</sub>，就能夠把這三個component graph中的vertex(也就是directed graph的SCC)給分開。</li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f7.png?raw=true" /></p>
<p><strong>圖三(c)：。</strong><br />
</center></p>
<p>那麼，該如何確保每一次都能找到「一條path上，從尾端至開頭的vertex順序」？</p>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f8.png?raw=true" /></p>
<p><strong>圖三(d)：。</strong><br />
</center></p>
<p>再觀察圖三(d)，分別以起點順序「C<sub>2</sub>、C<sub>3</sub>、C<sub>1</sub>」與起點順序「C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>」進行<code>DFS()</code>，配合圖三(c)，將發現，不論以哪個vertex作為起點，「<code>finish</code>的大小順序一定是C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>」。</p>
<p>更廣義地，假設現有C<sub>1</sub>與C<sub>2</sub>分別為directed graph中兩個互斥(disjoint)的SCC，並且vertex(X)屬於C<sub>1</sub>，vertex(Y)屬於C<sub>2</sub>：</p>
<ul>
<li>若directed graph中存在edge(X,Y)，那麼，C<sub>1</sub>集合中所有vertex的「最大<code>finish</code>」一定比C<sub>2</sub>集合中所有vertex的「最大<code>finish</code>」還要大。</li>
</ul>
<p>以圖三(e)為例，component graph的<span class="math">\(E^{SCC}\)</span>存在「從C<sub>1</sub>指向C<sub>2</sub>」以及「從C<sub>2</sub>指向C<sub>3</sub>」的edge，因此，若以SCC中vertex的「最大<code>finish</code>」代表<code>finish[SCC]</code>，<code>finish</code>的大小順序應為：<code>finish[C1]</code>&gt;<code>finish[C2]</code>&gt;<code>finish[C3]</code>，其中：</p>
<ul>
<li><span class="math">\(C_1=\)</span>{<span class="math">\(0,1,2,3\)</span>}，<code>finish[C1]</code><span class="math">\(=\)</span><code>finish[3]</code><span class="math">\(=18\)</span>。</li>
<li><span class="math">\(C_2=\)</span>{<span class="math">\(4,5\)</span>}，<code>finish[C2]</code><span class="math">\(=\)</span><code>finish[5]</code><span class="math">\(=10\)</span>。</li>
<li><span class="math">\(C_3=\)</span>{<span class="math">\(6,7,8\)</span>}，<code>finish[C3]</code><span class="math">\(=\)</span><code>finish[8]</code><span class="math">\(=6\)</span>。  </li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f9.png?raw=true" /></p>
<p><strong>圖三(e)：。</strong>
</center></p>
<p>考慮圖三(f)，仍然符合：<code>finish[C1]</code>&gt;<code>finish[C2]</code>&gt;<code>finish[C3]</code>：</p>
<ul>
<li><code>finish[C1]</code><span class="math">\(=\)</span><code>finish[0]</code><span class="math">\(=18\)</span>。</li>
<li><code>finish[C2]</code><span class="math">\(=\)</span><code>finish[5]</code><span class="math">\(=15\)</span>。</li>
<li><code>finish[C3]</code><span class="math">\(=\)</span><code>finish[6]</code><span class="math">\(=13\)</span>。</li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f10.png?raw=true" /></p>
<p><strong>圖三(f)：。</strong> 
</center></p>
<p>由以上推論，可以更新在圖三(c)時的說明至更廣義的結論：</p>
<ul>
<li>只要按照「<code>finish</code>小到大」的順序選取SCC中的vertex作為<code>DFS()</code>的起點，就能夠在<strong>Predecessor Subgraph</strong>中以<strong>Depth-First Forest</strong>分辨出所有SCC。</li>
</ul>
<p>到這裡為止，可以確認：</p>
<ol>
<li>需要第一次<code>DFS()</code>先取得<code>finish</code>。</li>
<li>再根據剛取得的<code>finish</code>之「順序」來判斷「第二次<code>DFS()</code>」的起點順序。</li>
<li>進行第二次<code>DFS()</code>來取得<code>predecessor</code>，並利用Predecessor Subgraph分辨出SCC。</li>
</ol>
<p>但是問題又來了。<br />
如果真的是按照「第一次<code>finish</code>由小到大」的順序選取SCC中的vertex作為第二次<code>DFS()</code>的起點，還是有可能失敗，因為第一次<code>DFS()</code>在選取起點時，並沒有對SCC的先備知識，可以視為隨機選取：</p>
<ul>
<li>若第一次<code>DFS()</code>結果如圖三(e)，則按照「<code>finish</code>由小到大」的順序選取起點，將依序選中「vertex(7)、vertex(4)、vertex(1)」作為起點進行第二次<code>DFS()</code>，那麼將得到如圖三(g)之結果，順利區分三個SCC。</li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f11.png?raw=true" /></p>
<p><strong>圖三(g)：。</strong> 
</center></p>
<ul>
<li>但是如果第一次<code>DFS()</code>結果如圖三(f)，按照「<code>finish</code>由小到大」的順序選取起點，只會選中vertex(3)作為起點，便把整個Graph搜尋完畢，最後Predecessor Subgraph又形成一整棵Depth-First Tree，如圖三(h)。</li>
</ul>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f12.png?raw=true" /></p>
<p><strong>圖三(h)：。</strong> 
</center></p>
<p>所以，先在Graph:G上執行第一次<code>DFS()</code>，得到<code>finish</code>後，按照<code>finish</code>由小到大的順序，作為第二次在Graph:G上執行<code>DFS()</code>的起點之方法，宣告失敗。</p>
<p>不過，還好有<strong>Transpose of Graph: G<sup>T</sup></strong>。</p>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f13.png?raw=true" /></p>
<p><strong>圖三(i)：。</strong> 
</center></p>
<p>觀察圖三(i)中的G與G<sup>T</sup>，發現：</p>
<ul>
<li>兩個Graph的SCC完全相同，皆為C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>。</li>
<li>SCC的<code>finish</code>順序完全相反。<ul>
<li>在G上，從C<sub>3</sub>無法往回走到C<sub>2</sub>，從C<sub>2</sub>無法往回走到C<sub>1</sub>。</li>
<li>在G<sup>T</sup>上，從C<sub>1</sub>無法往回走到C<sub>2</sub>，從C<sub>2</sub>無法往回走到C<sub>3</sub>。</li>
</ul>
</li>
</ul>
<p>根據以上特徵，若先在Graph:G上執行第一次<code>DFS()</code>，得到<code>finish</code>後，按照<code>finish</code>由大到小的順序，會是「C<sub>1</sub>、C<sub>2</sub>、C<sub>3</sub>」，而<strong>這個順序在Transpose of Graph: G<sup>T</sup>，就正好是「</strong><code>finish</code><strong>小到大」的順序</strong>。</p>
<p>因此，以「第一次<code>DFS()</code>所得到的<code>finish</code>之由大到小順序」選取起點，在G<sup>T</sup>上進行第二次<code>DFS()</code>，就可以先選到C<sub>1</sub>，由於無法從C<sub>1</sub>走回C<sub>2</sub>，因此<code>DFS()</code>在搜尋完C<sub>1</sub>內的所有vertex後，便形成自己的Depth-First Tree。接著再依序挑選C<sub>2</sub>、C<sub>3</sub>為起點進行搜尋，並且建立起各自SCC的Depth-First Tree。</p>
<p>如此一來，便找到了directed graph中的SCC。</p>
<p></br></p>
<p><a name="code"></a></p>
<h2>程式碼</h2>
<p>根據以上說明，演算法分成四個步驟：</p>
<ol>
<li>對G執行<code>DFS()</code>。</li>
<li>產生G<sup>T</sup>。</li>
<li>按照第一次<code>DFS()</code>所得到的<code>finish</code>由大到小的順序選取起點，對G<sup>T</sup>執行<code>DFS()</code>。</li>
<li>從第二次<code>DFS()</code>的<code>predecessor</code>找到Predecessor Subgraph。若directed graph有多個SCC，那麼Predecessor Subgraph就會是Depth-First Forest，其中的每一棵Depth-First Tree都是一個SCC。</li>
</ol>
<p>範例程式碼延續上一篇文章定義的<code>class Graph</code>，主要多了幾個函式：</p>
<ol>
<li><code>GetColor()</code>、<code>GetFinish()</code>、<code>GetPredecessor</code>：用來取得<code>color</code>、<code>finish</code>、<code>predecessor</code>。</li>
<li><code>GraphTranspose()</code>：產生G<sup>T</sup>。</li>
<li><code>VariableInitializeDFS()</code>：把原先<code>DFS()</code>主函式中，「配置記憶體」與「初始化」資料的部分獨立出來。</li>
<li><code>QuickSort()</code>等三個函式：用來得到<code>finish</code>由大致小的vertex順序。<ul>
<li>若共有6個vertex，經過一次<code>DFS()</code>後得到<code>finish</code>如圖四，那麼<code>QuickSort()</code>將會對<code>finish</code>進行排序，並且在排序的過程，一併將<code>finish</code>原先對應的vertex排序後，放入<code>finishLargetoSmall</code>。之後再利用<code>finishLargetoSmall</code>的順序，進行第二次<code>DFS()</code>。</li>
</ul>
</li>
<li><code>PrintSCCs()</code>：尋找SCC最主要的函式，主要包含上述的四個步驟。(其中有許多用以顯示資料項的指令，與尋找SCC無關)</li>
</ol>
<p><center>
<img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f18.png?raw=true" /></p>
<p><strong>圖四：。</strong> 
</center></p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;list&gt;</span>
<span class="cp">#include &lt;queue&gt;</span>
<span class="cp">#include &lt;iomanip&gt;      </span><span class="c1">// for std::setw()</span>

<span class="k">class</span> <span class="nc">Graph</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">num_vertex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">AdjList</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">color</span><span class="p">,</span>             <span class="c1">// 0:white, 1:gray, 2:black</span>
        <span class="o">*</span><span class="n">predecessor</span><span class="p">,</span>
        <span class="o">*</span><span class="n">distance</span><span class="p">,</span>          <span class="c1">// for BFS()</span>
        <span class="o">*</span><span class="n">discover</span><span class="p">,</span>          <span class="c1">// for DFS()</span>
        <span class="o">*</span><span class="n">finish</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Graph</span><span class="p">()</span><span class="o">:</span><span class="n">num_vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">){};</span>
    <span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span><span class="o">:</span><span class="n">num_vertex</span><span class="p">(</span><span class="n">N</span><span class="p">){</span>
        <span class="c1">// initialize Adj List</span>
        <span class="n">AdjList</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_vertex</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="nf">GetColor</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">];};</span>              <span class="c1">// 取得private data: color</span>
    <span class="kt">int</span> <span class="nf">GetFinish</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">finish</span><span class="p">[</span><span class="n">i</span><span class="p">];};</span>            <span class="c1">// 取得private data: finish</span>
    <span class="kt">int</span> <span class="nf">GetPredecessor</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">];};</span>  <span class="c1">// 取得private data: predecessor</span>

    <span class="kt">void</span> <span class="nf">AddEdgeList</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">BFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">Start</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">Start</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">DFSVisit</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">time</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">VariableInitializeDFS</span><span class="p">();</span>     <span class="c1">// 對DFS()需要的資料：color, discover, finish, predecessor</span>
                                      <span class="c1">// 進行「配置記憶體」與「初始化」</span>

    <span class="kt">void</span> <span class="nf">CCDFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex</span><span class="p">);</span>           <span class="c1">// 吃一個int, 表示起點vertex, 若沒給就從0開始</span>
    <span class="kt">void</span> <span class="nf">CCBFS</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">SetCollapsing</span><span class="p">(</span><span class="kt">int</span> <span class="n">vertex</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">PrintDataArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">);</span>  <span class="c1">// 列印出array[]</span>
    <span class="kt">void</span> <span class="nf">PrintFinish</span><span class="p">();</span>               <span class="c1">// 列印出 finish[]</span>
    <span class="kt">void</span> <span class="nf">PrintPredecessor</span><span class="p">();</span>          <span class="c1">// 列印出 predecessor[]</span>

    <span class="n">Graph</span> <span class="nf">GraphTranspose</span><span class="p">();</span>           <span class="c1">// 產生Transpose of Graph</span>
    <span class="kt">void</span> <span class="nf">PrintSCCs</span><span class="p">(</span><span class="kt">int</span> <span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>    <span class="c1">// 吃一個int, 表示起點vertex, 若沒給就從0開始</span>

    <span class="c1">// 利用QuickSort()得到 finish[] 由大致小的vertex順序</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">front</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vec2</span><span class="p">);</span>
    <span class="k">friend</span> <span class="kt">int</span> <span class="nf">Partition</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">front</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vec2</span><span class="p">);</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">y</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
    <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
    <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">Partition</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">front</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vec2</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">front</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vec2</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">end</span><span class="p">]);</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec2</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">vec2</span><span class="p">[</span><span class="n">end</span><span class="p">]);</span>

    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 把 i + 1 當成下一個 recurrsive call 的 中間斷點</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">front</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">vec2</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">front</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">Partition</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">front</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">vec2</span><span class="p">);</span>
        <span class="n">QuickSort</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">front</span><span class="p">,</span> <span class="n">pivot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">);</span>
        <span class="n">QuickSort</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">vec2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">PrintSCCs</span><span class="p">(</span><span class="kt">int</span> <span class="n">Start</span><span class="p">){</span>
    <span class="c1">// 第一次DFS(), 目的是取得finish[]</span>
    <span class="n">DFS</span><span class="p">(</span><span class="n">Start</span><span class="p">);</span>

    <span class="c1">// 顯示 第一次DFS()後的finish[]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;First DFS() on G, finish time:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">PrintFinish</span><span class="p">();</span>

    <span class="c1">// gT代表Transpose of Graph</span>
    <span class="n">Graph</span> <span class="nf">gT</span><span class="p">(</span><span class="n">num_vertex</span><span class="p">);</span>
    <span class="n">gT</span> <span class="o">=</span> <span class="n">GraphTranspose</span><span class="p">();</span>

    <span class="c1">// 矩陣 finishLargetoSmall[] 用來儲存 finish[] 由大至小的vertex順序</span>
    <span class="kt">int</span> <span class="n">finishLargetoSmall</span><span class="p">[</span><span class="n">num_vertex</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">finishLargetoSmall</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// QuickSort()會更新 finishLargetoSmall[] 成 finish[] 由大至小的vertex順序</span>
    <span class="n">QuickSort</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_vertex</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">finishLargetoSmall</span><span class="p">);</span>

    <span class="c1">// 列印出 finish[] 由大至小的vertex順序</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;finish time Large to Small:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">PrintDataArray</span><span class="p">(</span><span class="n">finishLargetoSmall</span><span class="p">);</span>

    <span class="c1">// 第二次DFS(), 執行在gT上, 先對四個資料「配置記憶體」且「初始化」</span>
    <span class="n">gT</span><span class="p">.</span><span class="n">VariableInitializeDFS</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gT</span><span class="p">.</span><span class="n">GetColor</span><span class="p">(</span><span class="n">finishLargetoSmall</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">gT</span><span class="p">.</span><span class="n">DFSVisit</span><span class="p">(</span><span class="n">finishLargetoSmall</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">time</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 顯示 第二次DFS()後的finish[]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Second DFS() on gT, finish time:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">gT</span><span class="p">.</span><span class="n">PrintFinish</span><span class="p">();</span>
    <span class="c1">// 顯示 第二次DFS()後的predecessor[]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;predecessor[] before SetCollapsing:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">gT</span><span class="p">.</span><span class="n">PrintPredecessor</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">gT</span><span class="p">.</span><span class="n">SetCollapsing</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="c1">// 顯示 SetCollapsing後的predecessor[]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;predecessor after SetCollapsing:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">gT</span><span class="p">.</span><span class="n">PrintPredecessor</span><span class="p">();</span>

    <span class="c1">// 如同在undirected graph中尋找connected component</span>
    <span class="kt">int</span> <span class="n">num_cc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gT</span><span class="p">.</span><span class="n">GetPredecessor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;SCC#&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">num_cc</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">gT</span><span class="p">.</span><span class="n">GetPredecessor</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">VariableInitializeDFS</span><span class="p">(){</span>
    <span class="n">color</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">num_vertex</span><span class="p">];</span>
    <span class="n">discover</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">num_vertex</span><span class="p">];</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">num_vertex</span><span class="p">];</span>
    <span class="n">predecessor</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">num_vertex</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">discover</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">finish</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">Graph</span> <span class="n">Graph</span><span class="o">::</span><span class="n">GraphTranspose</span><span class="p">(){</span>
    <span class="n">Graph</span> <span class="n">gT</span><span class="p">(</span><span class="n">num_vertex</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">AdjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">begin</span><span class="p">();</span><span class="n">itr</span> <span class="o">!=</span> <span class="n">AdjList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">gT</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">gT</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">PrintDataArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">array</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">PrintFinish</span><span class="p">(){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">finish</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Graph</span><span class="o">::</span><span class="n">PrintPredecessor</span><span class="p">(){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_vertex</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    <span class="n">Graph</span> <span class="n">g4</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span><span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span><span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span><span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span><span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span><span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">AddEdgeList</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Vertex(0) as starting point for the First DFS():</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">PrintSCCs</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Vertex(3) as starting point for the First DFS():</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">g4</span><span class="p">.</span><span class="n">PrintSCCs</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>output:</p>
<div class="highlight"><pre><span class="n">Vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">as</span> <span class="n">starting</span> <span class="n">point</span> <span class="k">for</span> <span class="n">the</span> <span class="n">First</span> <span class="n">DFS</span><span class="p">()</span><span class="o">:</span>

<span class="n">First</span> <span class="n">DFS</span><span class="p">()</span> <span class="n">on</span> <span class="n">G</span><span class="p">,</span> <span class="n">finish</span> <span class="nl">time</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
  <span class="mi">18</span>  <span class="mi">17</span>  <span class="mi">16</span>   <span class="mi">5</span>  <span class="mi">14</span>  <span class="mi">15</span>  <span class="mi">13</span>  <span class="mi">12</span>  <span class="mi">11</span>
<span class="n">finish</span> <span class="n">time</span> <span class="n">Large</span> <span class="n">to</span> <span class="nl">Small</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">5</span>   <span class="mi">4</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>   <span class="mi">3</span>
<span class="n">Second</span> <span class="n">DFS</span><span class="p">()</span> <span class="n">on</span> <span class="n">gT</span><span class="p">,</span> <span class="n">finish</span> <span class="nl">time</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
   <span class="mi">8</span>   <span class="mi">4</span>   <span class="mi">7</span>   <span class="mi">6</span>  <span class="mi">11</span>  <span class="mi">12</span>  <span class="mi">18</span>  <span class="mi">16</span>  <span class="mi">17</span>
<span class="n">predecessor</span><span class="p">[]</span> <span class="n">before</span> <span class="nl">SetCollapsing</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
  <span class="o">-</span><span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">0</span>   <span class="mi">2</span>   <span class="mi">5</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">8</span>   <span class="mi">6</span>
<span class="n">predecessor</span> <span class="n">after</span> <span class="nl">SetCollapsing</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
  <span class="o">-</span><span class="mi">1</span>   <span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">5</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">6</span>   <span class="mi">6</span>
<span class="n">SCC</span><span class="err">#</span><span class="mi">1</span><span class="o">:</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> 
<span class="n">SCC</span><span class="err">#</span><span class="mi">2</span><span class="o">:</span> <span class="mi">5</span> <span class="mi">4</span> 
<span class="n">SCC</span><span class="err">#</span><span class="mi">3</span><span class="o">:</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> 

<span class="n">Vertex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="n">as</span> <span class="n">starting</span> <span class="n">point</span> <span class="k">for</span> <span class="n">the</span> <span class="n">First</span> <span class="n">DFS</span><span class="p">()</span><span class="o">:</span>

<span class="n">First</span> <span class="n">DFS</span><span class="p">()</span> <span class="n">on</span> <span class="n">G</span><span class="p">,</span> <span class="n">finish</span> <span class="nl">time</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
  <span class="mi">16</span>  <span class="mi">15</span>  <span class="mi">17</span>  <span class="mi">18</span>  <span class="mi">14</span>  <span class="mi">13</span>  <span class="mi">12</span>  <span class="mi">11</span>  <span class="mi">10</span>
<span class="n">finish</span> <span class="n">time</span> <span class="n">Large</span> <span class="n">to</span> <span class="nl">Small</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
   <span class="mi">3</span>   <span class="mi">2</span>   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
<span class="n">Second</span> <span class="n">DFS</span><span class="p">()</span> <span class="n">on</span> <span class="n">gT</span><span class="p">,</span> <span class="n">finish</span> <span class="nl">time</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>  <span class="mi">12</span>  <span class="mi">11</span>  <span class="mi">18</span>  <span class="mi">16</span>  <span class="mi">17</span>
<span class="n">predecessor</span><span class="p">[]</span> <span class="n">before</span> <span class="nl">SetCollapsing</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">4</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">8</span>   <span class="mi">6</span>
<span class="n">predecessor</span> <span class="n">after</span> <span class="nl">SetCollapsing</span><span class="p">:</span>
   <span class="mi">0</span>   <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">3</span>   <span class="mi">4</span>   <span class="mi">5</span>   <span class="mi">6</span>   <span class="mi">7</span>   <span class="mi">8</span>
   <span class="mi">3</span>   <span class="mi">3</span>   <span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">4</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">6</span>   <span class="mi">6</span>
<span class="n">SCC</span><span class="err">#</span><span class="mi">1</span><span class="o">:</span> <span class="mi">3</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> 
<span class="n">SCC</span><span class="err">#</span><span class="mi">2</span><span class="o">:</span> <span class="mi">4</span> <span class="mi">5</span> 
<span class="n">SCC</span><span class="err">#</span><span class="mi">3</span><span class="o">:</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span>  
</pre></div>


<p>結果如圖五(a)與圖五(b)：</p>
<p><center>
<img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f14.png?raw=true" />  </p>
<p><img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f15.png?raw=true" /></p>
<p><strong>圖五(a)：第一次</strong><code>DFS()</code><strong>以vertex(0)作為起點。</strong> 
</center></p>
<p><center>
<img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f16.png?raw=true" />  </p>
<p><img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f17.png?raw=true" /></p>
<p><strong>圖五(b)：第一次</strong><code>DFS()</code><strong>以vertex(3)作為起點。</strong> 
</center></p>
<p></br></p>
<p>以上便是利用<code>DFS()</code>來尋找directed graph中的strongly connected component之應用。<br />
其中，<code>finish</code>之順序在DAG(directed acyclic graph)中扮演了關鍵角色。</p>
<p>下一篇將介紹如何利用<code>DFS()</code>尋找DAG的Topological sort(拓撲排序)，敬請期待。</p>
<p></br></p>
<hr />
<p><a name="ref"></a></p>
<h3>參考資料：</h3>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms, Ch22</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++, Ch6</a></li>
<li><a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/strongComponent.htm">Rashid Bin Muhammad：Strongly Connected Components</a></li>
<li><a href="http://www.geeksforgeeks.org/strongly-connected-components/">GeeksforGeeks：Strongly Connected Components</a></li>
</ul>
<p><a name="series"></a></p>
<p></br></p>
<h3>BFS/DFS系列文章</h3>
<p><a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html">Graph: Breadth-First Search(BFS，廣度優先搜尋)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html">Graph: Depth-First Search(DFS，深度優先搜尋)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html">Graph: 利用DFS和BFS尋找Connected Component</a><br />
<a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-strongly-connected-componentscc.html">Graph: 利用DFS尋找Strongly Connected Component(SCC)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html">Graph: 利用DFS尋找DAG的Topological Sort(拓撲排序)</a>  </p>
<p>回到目錄：</p>
<p><a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">目錄：演算法與資料結構</a></p>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/graph.html">Graph</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/dfs.html">DFS</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/dag.html">DAG</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>