<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Binary Tree: 建立一棵Binary Tree</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Binary Tree" />
        <meta name="tags" contents="Queue" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Second Round">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">
	<meta property="og:title" content="Binary Tree: 建立一棵Binary Tree">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2015-12-27 16:53:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Second Round</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Binary Tree: 建立一棵Binary Tree</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on 12 27, 2015
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h3>先備知識與注意事項</h3>
<p>在<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code">Binary Tree：Traversal</a>中，非常沒誠意地用暴力方式建了一棵Binary Tree，在本篇文章將提供一種文明的方法，由一個字元陣列(char array)輸入字母，並按照<a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#fullcomplete">Complete Binary Tree</a>之順序重新建立<em>那顆樹</em>。</p>
<p>其中，問題情境之輸入資料是一個字元陣列(char array)，為了方便處理，將會使用C++語言中的神器：<code>stringstream</code>，這裡礙於篇幅(與筆者自己也還在摸索)，就不多談避免誤導，<a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html">點進連結中</a>有非常詳細的說明，關於<code>istringstream</code>、<code>ostringstream</code>、<code>stringstream</code>等等template class之繼承關係(inheritance)。  </p>
<p>因為要按照Complete Binary Tree的規則建樹，可以想像的是，以下提供的Binary Tree之建立方法，基本上是在<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#level">Binary Tree：Traversal介紹過的level-order traversal</a>上加工，因此<a href="http://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html">Queue(佇列)</a>的概念會再次出現。</p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#description">問題描述</a></li>
<li><a href="#code">程式碼</a>   <ul>
<li><a href="#def">定義class TreeNode、class BinaryTree</a> </li>
<li><a href="#constructor">Constructor of BinaryTree</a> </li>
<li><a href="#func1">Function：LevelorderConstruct</a></li>
<li><a href="#func2">Function：InsertLevelorder</a></li>
</ul>
</li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#tree_series">Binary Tree系列文章</a></li>
</ul>
<p></br></p>
<p><a name="description"></a></p>
<h2>問題描述</h2>
<p>問題描述如下：</p>
<ul>
<li>給定一個字元陣列，欲按照Complete Binary Tree之位置規則建立一棵Binary Tree，若陣列元素之資料為大寫字母(ASCII：<span class="math">\(65\)</span>~<span class="math">\(90\)</span>)，則將其建立成Tree的node，若陣列元素為 ' x ' 則表示該位置沒有node。</li>
</ul>
<p>以<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code">Binary Tree：Traversal</a>中所提到的Binary Tree為例，如圖一：</p>
<p><center>
<img alt="binary tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f1.png?raw=true" /></p>
<p><strong>圖一：。</strong><br />
</center>   </p>
<p>其所對應的字元陣列即為：<code>A B C D E F x x x G H x I</code>，如圖二所示：</p>
<p><center>
<img alt="binary tree of char array" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f2.png?raw=true" /></p>
<p><strong>圖二：。</strong><br />
</center> </p>
<p>以下程式範例的目的就是要以如此文明的方式建立出如圖一的Binary Tree。</p>
<p></br></p>
<p><a name="code"></a></p>
<h2>程式碼</h2>
<p>(完整範例程式碼也可以看這裡：<a href="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/ExampleCode/BT_Construct_from_char_array.cpp">BT_Construct_from_char_array.cpp</a>)</p>
<p>先看看<code>main()</code>中，上半部分別為：</p>
<ul>
<li>原始資料：字元陣列；</li>
<li>以字元陣列建立一棵如圖二的Binary Tree，本篇重點在此；</li>
<li>以inorder traversal印出樹的資料。</li>
</ul>
<p><center>
<img alt="binary tree of char array" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f2.png?raw=true" /></p>
<p><strong>圖二：。</strong><br />
</center> </p>
<p>下半部則是示範以<code>queue</code>實現level-order traversal之小應用：以Complete Binary Tree之位置規則在樹中新增node，最後會把圖二之Binary Tree裡的「洞」給補起來，如圖四(b)。  </p>
<p><center>
<img alt="insertLMN" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f17.png?raw=true" />  </p>
<p><strong>圖四(b)：。</strong><br />
</center> </p>
<p>溫馨小提醒：純粹以inorder traversal之結果並無法驗證樹之結構正如圖一(舉例來說：以inorder traversal對某個Linked list也可能得出相同結果)，因此，建議還是使用任何可取得的debugger把pointer全部攤開。</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;sstream&gt;</span>
<span class="cp">#include &lt;queue&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="s">&quot;A B C D E F x x x G H x I&quot;</span><span class="p">;</span>
    <span class="n">BinaryTree</span> <span class="n">T</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>                <span class="c1">// 以level-order規則建立Binary Tree</span>
    <span class="n">T</span><span class="p">.</span><span class="n">Inorder_by_parent</span><span class="p">();</span>      <span class="c1">// 以inorder-traversal印出Binary Tree</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">T</span><span class="p">.</span><span class="n">InsertLevelorder</span><span class="p">(</span><span class="sc">&#39;K&#39;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InsertLevelorder</span><span class="p">(</span><span class="sc">&#39;L&#39;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InsertLevelorder</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InsertLevelorder</span><span class="p">(</span><span class="sc">&#39;N&#39;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">Inorder_by_parent</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>在經過一連串程式碼後，預期得到的output：</p>
<div class="highlight"><pre><span class="n">D</span> <span class="n">B</span> <span class="n">G</span> <span class="n">E</span> <span class="n">H</span> <span class="n">A</span> <span class="n">F</span> <span class="n">I</span> <span class="n">C</span>   
<span class="n">L</span> <span class="n">D</span> <span class="n">M</span> <span class="n">B</span> <span class="n">G</span> <span class="n">E</span> <span class="n">H</span> <span class="n">A</span> <span class="n">N</span> <span class="n">F</span> <span class="n">I</span> <span class="n">C</span> <span class="n">K</span>    
</pre></div>


<p></br> </p>
<p><a name="def"></a></p>
<h3>定義class TreeNode、class BinaryTree</h3>
<p>這裡對<code>class TreeNode</code>與<code>class BinaryTree</code>之定義，與<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#ex_code">上一篇文章</a>之最大不同在於資料的隱蔽性，因為在此不需要在<code>main()</code>中存取任何pointer(<code>root</code>、<code>leftchild</code>、<code>rightchild</code>)，因此將之放進<strong>private</strong>區塊。</p>
<p>在<code>class BinaryTree</code>除了上一篇介紹過的inorder traversal外，多了兩個新朋友<code>LevelorderConstruct()</code>與<code>InsertLevelorder()</code>，前者即是本篇主角，吃進<code>stringstream</code>後，把樹建出來；後者純粹是好玩，其功能為「以Complete Binary Tree之位置規則，在理應出現node的位置，新增node」，能夠儘量減少在新增node時增加樹高(height)。</p>
<p>關於Inorder-traversal的三個函式<code>leftmost()</code>、<code>InorderSuccessor()</code>以及<code>Inorder_by_parent()</code>請參考上一篇：<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#in_parent">Binary Tree:Traversal(尋訪)/In-Order Traversal by Parent Field</a>。</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="p">()</span><span class="o">:</span><span class="n">leftchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">rightchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">parent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">data</span><span class="p">(</span><span class="sc">&#39;x&#39;</span><span class="p">){};</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">leftchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">rightchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">parent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">data</span><span class="p">(</span><span class="n">s</span><span class="p">){};</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BinaryTree</span><span class="p">()</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="mi">0</span><span class="p">){};</span>
    <span class="n">BinaryTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">LevelorderConstruct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">InsertLevelorder</span><span class="p">(</span><span class="kt">char</span> <span class="n">data</span><span class="p">);</span>

    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">InorderSuccessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Inorder_by_parent</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>


<p></br>  </p>
<p><a name="constructor"></a></p>
<h3>Constructor of BinaryTree</h3>
<p><code>class BinaryTree</code>的constructor很直觀，拿到一個字元陣列，先送進<code>stringstream</code>後，再由<code>stringstream</code>放進樹中。</p>
<p>此處先對樹的<code>root</code>進行記憶體配置以及賦值，剩下的字母將利用<code>LevelorderConstruct()</code>以level-order的方式建立出Binary Tree。</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="n">BinaryTree</span><span class="o">::</span><span class="n">BinaryTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span>  <span class="n">ss</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">;</span>                     <span class="c1">// magic!</span>

    <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>           <span class="c1">// allocate memory for root</span>
    <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>              <span class="c1">// assign character to root</span>

    <span class="n">LevelorderConstruct</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p></br></p>
<p><a name="func1"></a></p>
<h3>Function：LevelorderConstruct</h3>
<p>在看<code>LevelorderConstruct()</code>的函式主體之前，再看一眼<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#level">level-order traversal</a>，概念上即是藉著<code>queue</code>的「先排隊就先購票」特性，在同一個level中，只要確保由左至右將node放進<code>queue</code>中，便能確保在進入下一個level後，以先前放入node之順序進行visiting。  </p>
<p>整份程式碼的關鍵在於神器<code>stringstream &amp;ss</code>，只要不斷地透過<code>ss &gt;&gt; data</code>，<code>ss</code>便會自動尋找下一筆資料(字母)餵進<code>data</code>。</p>
<p><code>while</code>的條件式表示，若<code>ss &gt;&gt; data</code>失敗，也就是再也無法從<code>ss</code>拿到字母放進<code>data</code>，意味者所有字母已經全數檢查/輸入完畢，即結束迴圈。</p>
<p>在<code>while</code>內，新增條件用來判斷從<code>stringstream</code>中輸出的字母是「大寫字母」(ASCII：<span class="math">\(65\)</span>~<span class="math">\(90\)</span>)還是「x」，前者要放入樹中建成node，後者則忽略不計。  </p>
<p>在每一次迴圈中，會利用<code>ss &gt;&gt; data</code>輸入兩個字母，分別為<code>current</code>的<code>leftchild</code>與<code>rightchild</code>，因此，如果原本字元陣列是奇數筆資料，就會在<code>while</code>迴圈的中間輸入完畢，即跳出迴圈。</p>
<p><code>LevelorderConstruct()</code>程式定義如下：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">LevelorderConstruct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">){</span>

    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>         <span class="c1">// create a queue to handle level-roder rule</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>        <span class="c1">// point *current to root</span>
    <span class="kt">char</span> <span class="n">data</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span>                 <span class="c1">// initializa data as &#39;x&#39;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">65</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">){</span>                <span class="c1">// 處理current的leftchild</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>  <span class="c1">// call constructor TreeNode(char s)</span>
            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">)){</span>                           <span class="c1">// 有可能char array含有奇數筆資料</span>
            <span class="k">break</span><span class="p">;</span>                                    <span class="c1">// 所以在這裡結束迴圈</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">65</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">){</span>                <span class="c1">// 處理current的rightchild</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>        <span class="c1">// call constructor TreeNode()</span>
            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>                    <span class="c1">// assign data to new_node</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>                          <span class="c1">// 從queue中更新current</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>                                      <span class="c1">// 更新queue</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>詳細步驟如下：</p>
<ul>
<li>首先，在Binary Tree的constructor中，先配置<code>root</code>的記憶體位置，並透過第一次<code>ss &gt;&gt; root-&gt;data</code>將第一個字母放進<code>root</code>中，如圖三(a)。</li>
</ul>
<p><center>
<img alt="construct_0" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f3.png?raw=true" /></p>
<p><strong>圖三(a)：從ss取出第一個字母'A'放進<code>root</code>。</strong><br />
</center> </p>
<p>接著進入<code>while</code>迴圈。  </p>
<ul>
<li>條件式：<code>ss &gt;&gt; data</code>若為真，表示成功從<code>ss</code>中取出字母，傳進<code>data</code>。  </li>
<li>進入迴圈後，先判斷取出的字母若為大寫字母(在此為<strong>'B'</strong>)，即生成一個新的<code>new_node</code>。</li>
<li>接著將B放進<code>new_node</code>中(這裡是透過<code>class TreeNode</code>的constructor完成)，並將<code>CurrentNode</code>(在此為A)的left child指向<code>new_node</code>，如圖三(b)。  </li>
<li>在<code>queue</code>  的部分，若成功建立出新的node(此為B)，便把B放進<code>queue</code>的隊伍中，表示之後將要把<code>CurrentNode</code>移到B，繼續往下建立新的node。</li>
</ul>
<p><center> 
<img alt="construct_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f4.png?raw=true" /></p>
<p><strong>圖三(b)：。</strong><br />
</center> </p>
<p>在同一個迴圈裡，建立完<code>CurrentNode</code>的left child後，接著嘗試建立right child。  </p>
<ul>
<li>條件式：<code>if( !(ss &gt;&gt; data) )</code>若為真，表示<code>ss</code>中的字母已經讀取完畢，即跳出迴圈(<code>break</code>)。若否，則繼續從<code>ss</code>中讀取字母。</li>
<li>判斷字母是否為大寫字母(此為<strong>'C'</strong>)，便如同生成left child之方法，建立新的<code>new_node</code>、配置記憶體、將字母<strong>'C'</strong>放進<code>new_node</code>中，並將<code>CurrentNode</code>之right child指向<code>new_node</code>，如圖三(c)。</li>
<li>已成功建立新的node(C)，便把C放進<code>queue</code>的隊伍中，表示之後將要把<code>CurrentNode</code>移到B，繼續往下建立新的node。</li>
</ul>
<p>此時，<code>queue</code>裡有兩個node，分別為B與C，要注意的是，排隊時，先進入隊伍的人會代表隊伍的前方，因此B為<code>queue</code>的<strong>Front</strong>，C為<code>queue</code>的<strong>Back</strong>。</p>
<p><center>
<img alt="construct_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f5.png?raw=true" />  </p>
<p><strong>圖三(c)：。</strong><br />
</center> </p>
<p>在建立完<code>CurrentNode</code>的left child與right child後，接著要移動<code>CurrentNode</code>，作為下一個<code>while</code>迴圈的起點。  </p>
<p><code>queue</code>的功能便是提供<code>CurrentNode</code>移動的依據：</p>
<ul>
<li>一律將<code>queue</code>隊伍的第一個node視作新的<code>CurrentNode</code>：<ul>
<li><code>CurrentNode = q.front();</code>。</li>
</ul>
</li>
<li>將<code>CurrentNode</code>移動至B後，便把B從<code>queue</code>移除(<code>q.pop();</code>)，如圖三(d)。</li>
</ul>
<p>如此便能保證，<code>CurrentNode</code>的移動會依照level-order「由上至下、由左至右」之順序。</p>
<p><center>
<img alt="construct_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f6.png?raw=true" />  </p>
<p><strong>圖三(d)：。</strong><br />
</center> </p>
<p>進入第二次<code>while</code>迴圈後，重複以上之步驟：</p>
<ul>
<li>從<code>ss</code>取出字母，放進<code>data</code>。</li>
<li>判斷<code>data</code>是否為大寫，若是，便依序在<code>CurrentNode</code>之left child與right child建立新的node。</li>
<li>並且，將成功建立之node放進<code>queue</code>隊伍中，用作之後<code>CurrentNode</code>移動之用。</li>
</ul>
<p>仔細觀察圖三(e)至圖三(h)之<code>ss</code>與<code>CurrentNode</code>之移動，與<code>queue</code>的變化：</p>
<p><center>
<img alt="construct_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f7.png?raw=true" />  </p>
<p><strong>圖三(e)：。</strong><br />
</center> </p>
<p><center>
<img alt="construct_5" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f8.png?raw=true" />  </p>
<p><strong>圖三(f)：。</strong><br />
</center> </p>
<p><center>
<img alt="construct_6" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f9.png?raw=true" />  </p>
<p><strong>圖三(g)：。</strong><br />
</center> </p>
<p><center>
<img alt="construct_7" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f10.png?raw=true" />  </p>
<p><strong>圖三(h)：。</strong><br />
</center></p>
<ul>
<li>在建立完C的left child後，從<code>ss</code>讀取到字母<strong>'x'</strong>，因為其並非大寫字母，表示C沒有right child，因此跳過生成新的node之步驟，如圖三(i)。  </li>
</ul>
<p><center>
<img alt="construct_8" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f11.png?raw=true" />  </p>
<p><strong>圖三(i)：。</strong><br />
</center> </p>
<ul>
<li>若沒有生成新的node，便沒有新的node進入<code>queue</code>排隊。</li>
<li>接著要繼續將<code>CurrentNode</code>移動到<code>queue</code>的第一個元素，也就是D，並把D從<code>queue</code>中移除，如圖三(j)。</li>
</ul>
<p><center>
<img alt="construct_9" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f12.png?raw=true" />  </p>
<p><strong>圖三(j)：。</strong><br />
</center></p>
<ul>
<li>當<code>CurrentNode</code>移動到D之後，<code>ss</code>連續放兩個<strong>'x'</strong>進入<code>data</code>，表示D的兩個child pointer皆指向<code>NULL</code>。</li>
<li>由於沒有新的node產生，<code>queue</code>的隊伍便沒有更新，如圖三(k)。</li>
</ul>
<p><center>
<img alt="construct_10" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f13.png?raw=true" /></p>
<p><strong>圖三(k)：。</strong><br />
</center> </p>
<p>接著，重複步驟：</p>
<ul>
<li>移動<code>CurrentNode</code>至<code>queue</code>的第一個元素所指示的node。</li>
<li>從<code>ss</code>讀取字母，判斷其若為大寫字母，便配置記憶體、產生新的node接在<code>CurrentNode</code>的child pointer上。</li>
<li>若有生成新的node，則將該node推入<code>queue</code>的隊伍。</li>
</ul>
<p><center>
<img alt="construct_11" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f14.png?raw=true" />  </p>
<p><strong>圖三(l)：。</strong><br />
</center> </p>
<ul>
<li>直到<code>ss</code>輸出最後一個字母<strong>'I'</strong>後，這棵樹便建立完成。</li>
<li>由於，<code>ss</code>已全數讀取完畢，敘述句：<code>ss &gt;&gt; data</code>不成立，因此結束迴圈。</li>
</ul>
<p><center>
<img alt="construct_12" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f15.png?raw=true" />  </p>
<p><strong>圖三(m)：。</strong><br />
</center> </p>
<p></br>  </p>
<p></br>
<a name="func2"></a></p>
<h3>Function：InsertLevelorder</h3>
<p>函式<code>InsertLevelorder()</code>的功能是，能夠按照Complete Binary Tree的位置順序放置新增的node，例如，若要在圖三之樹上新增帶有字母<strong>'K'</strong>的node，則<code>T.InsertLevelorder('K')</code>便會將<strong>'K'</strong>建成C的right child，如圖四(a)：</p>
<p><center>
<img alt="insertK" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f16.png?raw=true" />  </p>
<p><strong>圖四(a)：。</strong><br />
</center> </p>
<p>再依序新增L、M、N：</p>
<ul>
<li><code>T.InsertLevelorder('L');</code>  </li>
<li><code>T.InsertLevelorder('M');</code>  </li>
<li><code>T.InsertLevelorder('N');</code></li>
</ul>
<p>即會得到如圖四(b)的樹：</p>
<p><center>
<img alt="insertLMN" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/f17.png?raw=true" />  </p>
<p><strong>圖四(b)：。</strong><br />
</center> </p>
<p>程式碼之邏輯與<code>LevelorderConstruct()</code>大同小異，最主要的部分就是利用<code>queue</code>來記錄<code>CurrentNode</code>移動的順序：</p>
<ul>
<li>首先，將<code>current</code>設成<code>root</code>，若樹存在，則進入<code>while</code>迴圈。</li>
<li>接著要開始「找空位」，若<code>current</code>之left child已經有node，則將之放入<code>queue</code>中，在下次迴圈將以此node作為<code>current</code>，若left child還沒有node，便產生帶有<code>data</code>之新node，並將其建立成<code>current</code>之left child。<br />
當「parent指向child」與「child指向parent」的pointer連接完成後，便結束迴圈。</li>
<li>對<code>current</code>之right child進行相同之步驟。</li>
</ul>
<p>如此便能有效控制Binary Tree之樹高(height)，使pointer所配置之記憶體空間有效利用，亦能夠減少traversal(以及其他操作)所需的時間。</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">InsertLevelorder</span><span class="p">(</span><span class="kt">char</span> <span class="n">data</span><span class="p">){</span>    

    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>               <span class="c1">// current的leftchild沒有空位</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span>                <span class="c1">// 將其推進queue中</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>                                          <span class="c1">// current的leftchild有空位</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>   <span class="c1">// 建立新的node, 將字母放在這裡</span>
            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
            <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>                         
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>             <span class="c1">// current的rightchild沒有空位</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span>               <span class="c1">// 將其推進queue中</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>                                          <span class="c1">// current的rightchild有空位</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>   <span class="c1">// 建立新的node, 將字母放在這裡</span>
            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>                
            <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p></br><br />
以上便是利用<code>queue</code>執行level-order方式建立Binary Tree之範例。<br />
另外，<a href="http://www.geeksforgeeks.org/level-order-tree-traversal/">利用遞迴的方式，外帶一個迴圈來進行level-order traversal</a>，也能夠完成相同的功能。</p>
<p></br></p>
<hr />
<p><a name="ref"></a></p>
<h3>參考資料：</h3>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms, Ch12</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++, Ch5</a></li>
<li><a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html">C++ Programming Language：Stream IO and File IO</a></li>
<li><a href="http://www.geeksforgeeks.org/level-order-tree-traversal/">GeeksforGeeks：Level Order Tree Traversal</a></li>
</ul>
<p></br></p>
<p><a name="tree_series"></a></p>
<h3>Binary Tree系列文章</h3>
<p><a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html">Binary Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">Binary Tree: 建立一棵Binary Tree</a>  </p>
<p>回到目錄：</p>
<p><a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">目錄：演算法與資料結構</a></p>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/binary-tree.html">Binary Tree</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/queue.html">Queue</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>