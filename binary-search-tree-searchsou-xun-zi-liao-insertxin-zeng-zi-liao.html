<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Binary Search Tree" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Second Round">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html">
	<meta property="og:title" content="Binary Search Tree: Search(搜尋資料)、Insert(新增資料)">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2016-01-03 20:17:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Second Round</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on  1 03, 2016
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h3>先備知識與注意事項</h3>
<p>(完整範例程式碼也可以看這裡：<a href="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/ExampleCode/BST_Search_Insert.cpp">BST_Search_Insert.cpp</a>)</p>
<p>在開始介紹search(搜尋資料)與insert(新增資料)之前，先定義好<code>class TreeNode</code>與<code>class BST</code>，順便對未來將介紹的其他member function(成員函式)留下美好的第一印象：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;queue&gt;</span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">BST</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">element</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">TreeNode</span><span class="p">()</span><span class="o">:</span><span class="n">leftchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">rightchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">parent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">key</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">element</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">){};</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">string</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">leftchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">rightchild</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">parent</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">key</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="n">element</span><span class="p">(</span><span class="n">b</span><span class="p">){};</span>

    <span class="kt">int</span> <span class="nf">GetKey</span><span class="p">(){</span><span class="k">return</span> <span class="n">key</span><span class="p">;}</span>              <span class="c1">// 為了在main()要能夠檢視node是否正確</span>
    <span class="n">string</span> <span class="nf">GetElement</span><span class="p">(){</span><span class="k">return</span> <span class="n">element</span><span class="p">;}</span>   <span class="c1">// 才需要這兩個member function讀取private data</span>

    <span class="c1">// 其餘情況, 因為class BST是class TreeNode的friend class</span>
    <span class="c1">// 在class BST的member function中, 可以直接存取class TreeNode的private data</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">BST</span><span class="p">;</span>   <span class="c1">// 放在 private 或 public 都可以 </span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BST</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Successor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BST</span><span class="p">()</span><span class="o">:</span><span class="n">root</span><span class="p">(</span><span class="mi">0</span><span class="p">){};</span>    

    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Search</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">InsertBST</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="n">string</span> <span class="n">element</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">InorderPrint</span><span class="p">();</span>        <span class="c1">// 可以用來確認BST是否建立成功</span>
    <span class="kt">void</span> <span class="nf">Levelorder</span><span class="p">();</span>          <span class="c1">// 可以確認BST是否建立成功</span>
<span class="p">};</span>
</pre></div>


<p>小小備註：範例程式碼只是其中一種可行的方法，實作方法並不唯一，筆者相信有更優秀的寫法(有效利用記憶體、避免memory leak等議題)，建議讀者可以多多參考例如<a href="http://codereview.stackexchange.com/">Stack Exchange:Code Review</a>等等眾多優秀的網站，看網友的程式碼的寫法以及由該份程式碼所開啟的討論串，應該會對實際寫作技巧有些幫助。  </p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#search">BST::Search(搜尋)</a></li>
<li><a href="#insert">BST::InsertBST(新增資料)</a></li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#tree_series">BST系列文章</a></li>
</ul>
<p></br></p>
<p><a name="search"></a></p>
<h2>BST::Search(搜尋)</h2>
<p>BST的<code>Search()</code>操作，便是根據BST的特徵：Key(L)&lt;Key(Current)&lt;Key(R)，判斷<code>Current</code>應該往left subtree走，還是往right subtree走。</p>
<p>現有一棵BST如圖一(a)所示：</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f1.png?raw=true" /></p>
<p><strong>圖一(a)：。</strong><br />
</center>   </p>
<p>搜尋結果可能成功，可能失敗，以下便分別以兩個KEY值作說明。</p>
<h3>搜尋成功</h3>
<p>若現在要從BST中搜尋基紐隊長，便以基紐隊長的KEY(<span class="math">\(627\)</span>)進入BST。  </p>
<p>進入BST後，便把用來移動的<code>Current</code>指向<code>root</code>，如圖一(b)。  </p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f2.png?raw=true" /></p>
<p><strong>圖一(b)：。</strong><br />
</center> </p>
<p>接著將KEY(<span class="math">\(627\)</span>)和比克(<code>root</code>)的戰鬥力(<span class="math">\(513\)</span>)比較，結果是基紐隊長戰勝，因此，基紐隊長如果在BST裡面，應該會長在比克的right subtree裡面，於是便將<code>Current</code>往比克的right child(達爾)移動，如圖一(c)。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f3.png?raw=true" /></p>
<p><strong>圖一(c)：。</strong><br />
</center> </p>
<p>將<code>Current</code>移動到達爾之後，再將KEY(<span class="math">\(627\)</span>)與達爾的戰鬥力(<span class="math">\(524\)</span>)比較，結果仍然是基紐隊長大勝，因此步驟同上，繼續將<code>Current</code>往達爾的right child(弗力札)移動，如圖一(d)。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f4.png?raw=true" /></p>
<p><strong>圖一(d)：。</strong><br />
</center> </p>
<p>將<code>Current</code>移動到弗力札之後，再將KEY(<span class="math">\(627\)</span>)與弗力札的戰鬥力(<span class="math">\(709\)</span>)比較，結果是弗力札略勝，於是便往弗力札的left child尋找基紐隊長，如圖一(e)。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f5.png?raw=true" /></p>
<p><strong>圖一(e)：。</strong><br />
</center></p>
<p>此時，<code>Current</code>的Key(<span class="math">\(627\)</span>)與傳送進<code>Search()</code>的KEY(<span class="math">\(627\)</span>)相同，便確認<code>Current</code>即為基紐隊長，於是跳出<code>while</code>迴圈，並傳回<code>Current</code>。  </p>
<p>宣告搜尋成功。</p>
<h3>搜尋失敗</h3>
<p>若現在要從BST中尋找克林，便以克林的戰鬥力(<span class="math">\(2\)</span>)作為KEY(<span class="math">\(2\)</span>)，進入<code>Search()</code>。  </p>
<p>進入BST後，同樣把用來移動的<code>Current</code>指向<code>root</code>，如圖一(b)。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f2.png?raw=true" /></p>
<p><strong>圖一(b)：。</strong><br />
</center> </p>
<p>接著便將KEY(<span class="math">\(2\)</span>)和比克的戰鬥力(<span class="math">\(513\)</span>)比較，結果是比克勝出，如果克林(<span class="math">\(2\)</span>)在這棵BST中，應該會長在比克的left subtree上，於是將<code>Currnet</code>往比克的left child(龜仙人)移動，如圖一(f)。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f6.png?raw=true" /></p>
<p><strong>圖一(f)：。</strong><br />
</center> </p>
<p>將<code>Current</code>移動至龜仙人後，將KEY(<span class="math">\(2\)</span>)和龜仙人的戰鬥力(<span class="math">\(8\)</span>)比較，便判斷出，要將<code>Current</code>往龜仙人的left child移動，如圖一(f)。  </p>
<p>然而，由於龜仙人沒有left child，於是<code>Current</code>指向<code>NULL</code>，便跳出迴圈，並回傳<code>NULL</code>，即表示搜尋失敗，克林不在BST中。</p>
<p>以下是<code>BST::Search()</code>的範例程式碼，其中，有兩種情況會跳出<code>while</code>迴圈：</p>
<ol>
<li><code>Current</code>移動到<code>NULL</code>，表示搜尋失敗。</li>
<li>KEY與<code>Current</code>的key相同，表示搜尋成功；</li>
</ol>
<p>這兩種情況作為條件式(condition)的先後順序很重要，因為如果<code>Current</code>是<code>NULL</code>，便不能對其<code>key</code>做存取，會產生諸如<strong>BAD_ACCESS</strong>的錯誤(error)。</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="n">TreeNode</span><span class="o">*</span> <span class="n">BST</span><span class="o">::</span><span class="n">Search</span><span class="p">(</span><span class="kt">int</span> <span class="n">KEY</span><span class="p">){</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>               <span class="c1">// 將curent指向root作為traversal起點</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">KEY</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 兩種情況跳出迴圈：</span>
                                                      <span class="c1">// 1.沒找到 2.有找到</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KEY</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">){</span>                      
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>   <span class="c1">// 向左走</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>  <span class="c1">// 向右走</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p></br> </p>
<p><a name="insert"></a></p>
<h2>BST::InsertBST(新增資料)</h2>
<p>函式<code>InsertBST()</code>的概念，可以視為<code>Search()</code>的延伸：</p>
<ol>
<li>根據BST對Key之規則，先找到將要新增之node「適合的位置」；</li>
<li>再將欲新增的node接上BST。</li>
</ol>
<p>要尋找「對新增node而言的適當位置」，需要召喚一位「哨兵」先行探路，而「將會成為新增node的<strong>parent node</strong>(準新手爸媽)」的那個node，則跟著「哨兵」的腳步，往前推進。 </p>
<p>定義「哨兵」為<strong>x</strong>，「準新手爸媽」為<strong>y</strong>，現欲新增「比克(513)」進入圖二(a)的BST。<br />
(這裡的「哨兵<strong>x</strong>」具有<code>BST::Search()</code>中<code>Current</code>的功能。)</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f7.png?raw=true" /></p>
<p><strong>圖二(a)：。</strong><br />
</center> </p>
<p>如圖二(a)，剛進入BST時，「哨兵<strong>x</strong>」進到<code>root</code>，而「準新手爸媽<strong>y</strong>」設為<code>root</code>的parent，即為<code>NULL</code>。  </p>
<p>接著，將欲新增node之Key(比克(<span class="math">\(513\)</span>))與「哨兵<strong>x</strong>」之Key(龜仙人(<span class="math">\(8\)</span>))相比，比克的戰鬥力比龜仙人高，所以比克應該要長在龜仙人的right subtree，因此把「哨兵<strong>x</strong>」往龜仙人的right child(悟空)移動，並且更新「準新手爸媽<strong>y</strong>」為龜仙人，如圖二(b)。</p>
<ul>
<li>若這棵BST裡沒有悟空(<span class="math">\(1000\)</span>)長在龜仙人的right child位置，那麼比克(<span class="math">\(513\)</span>)就會變成龜仙人的right child，所以稱龜仙人是「準新手爸媽」。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f8.png?raw=true" /></p>
<p><strong>圖二(b)：。</strong><br />
</center> </p>
<p>接著，繼續比較欲新增node之Key(比克(<span class="math">\(513\)</span>))與「哨兵<strong>x</strong>」之Key(悟空(<span class="math">\(1000\)</span>))，結果是悟空的戰鬥力較高，比克應該要長在悟空的left subtree，因此，將「哨兵<strong>x</strong>」往悟空的left child(<code>NULL</code>)移動，同時更新「準新手爸媽<strong>y</strong>」為悟空，如圖二(c)。</p>
<p>更新後，「準新手爸媽<strong>y</strong>」成為悟空，「哨兵<strong>x</strong>」指向<code>NULL</code>壯烈犧牲，即達到跳出迴圈之條件。此時，便找到了「新增node」之適當位置。  </p>
<p>那個「適當位置」在哪裡呢？就是「準新手爸媽<strong>y</strong>」的child pointer。<br />
表示比克(<span class="math">\(513\)</span>)一定會是悟空(<span class="math">\(1000\)</span>)的child。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f9.png?raw=true" /></p>
<p><strong>圖二(c)：。</strong><br />
</center> </p>
<p>下一步，便是比較欲新增node之Key(比克(513))與「準新手爸媽<strong>y</strong>」之Key(悟空(1000))來判斷要接在left child還是right child的位置。<br />
比較發現悟空戰鬥力較高，因此，比克(513)便成為「準新手爸媽<strong>y</strong>」的left child，如圖二(d)，便成功把比克(513)接到BST上。</p>
<p>如此便完成了於BST中新增資料。</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f10.png?raw=true" /></p>
<p><strong>圖二(d)：。</strong><br />
</center> </p>
<p>以下是<code>InsertBST()</code>的範例程式碼，關鍵便是「哨兵<strong>x</strong>」與「準新手爸媽<strong>y</strong>」的冒險之旅：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">void</span> <span class="n">BST</span><span class="o">::</span><span class="n">InsertBST</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="n">string</span> <span class="n">element</span><span class="p">){</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 準新手爸媽</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        <span class="c1">// 哨兵</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">insert_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>   <span class="c1">// insert_node為將要新增的node</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">// 在while中, 以如同Search()的方式尋找適當的位置       </span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>                          <span class="c1">// y先更新到原來x的位置</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">insert_node</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">){</span> <span class="c1">// 判斷x是要往left- 還是right- 前進</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>                                   <span class="c1">// 跳出迴圈後, x即為NULL</span>
                                        <span class="c1">// y即為insert_node的parent</span>
    <span class="n">insert_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>            <span class="c1">// 將insert_node的parent pointer指向y</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>                     <span class="c1">// 下面一組if-else, 把insert_node接上BST</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">insert_node</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">){</span>
        <span class="n">y</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">y</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>有了<code>BST::InsertBST()</code>後，就可以用土法煉鋼的方式建立一棵如圖二(d)的BST，再以<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a>介紹過的Inorder Traversal與Level-Order Traversal檢驗，順便測試BST中是否有Key(<span class="math">\(1000\)</span>)與Key(<span class="math">\(73\)</span>)這兩筆資料：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">BST</span> <span class="n">T</span><span class="p">;</span>

    <span class="n">T</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s">&quot;龜仙人&quot;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="s">&quot;悟空&quot;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;克林&quot;</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="mi">513</span><span class="p">,</span><span class="s">&quot;比克&quot;</span><span class="p">);</span>


    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Inorder Traversal:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">T</span><span class="p">.</span><span class="n">InorderPrint</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Level-order Traversal:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">T</span><span class="p">.</span><span class="n">Levelorder</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">Search</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;There is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">GetElement</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;no element with Key(1000)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">Search</span><span class="p">(</span><span class="mi">73</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;There is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">GetElement</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;no element with Key(73)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>output: </p>
<div class="highlight"><pre><span class="n">Inorder</span> <span class="nl">Traversal</span><span class="p">:</span>
<span class="err">克林</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="err">龜仙人</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="err">比克</span><span class="p">(</span><span class="mi">513</span><span class="p">)</span> <span class="err">悟空</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Level</span><span class="o">-</span><span class="n">order</span> <span class="nl">Traversal</span><span class="p">:</span>
<span class="err">龜仙人</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="err">克林</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="err">悟空</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="err">比克</span><span class="p">(</span><span class="mi">513</span><span class="p">)</span>

<span class="n">There</span> <span class="n">is</span> <span class="err">悟空</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">no</span> <span class="n">element</span> <span class="n">with</span> <span class="n">Key</span><span class="p">(</span><span class="mi">73</span><span class="p">)</span>
</pre></div>


<p>結果看起來與圖二(d)一致：</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f11.png?raw=true" /></p>
<p><strong>圖二(d)：。</strong><br />
</center> </p>
<p>以上便是BST中<code>Search()</code>與<code>InsertBST()</code>之介紹。  </p>
<p>只要掌握BST的性質Key(L)&lt;Key(Current)&lt;Key(R)與樹中的Traversal(pointer的移動)即可輕鬆上路。 </p>
<p></br></p>
<hr />
<p><a name="ref"></a></p>
<h3>參考資料：</h3>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms, Ch12</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++, Ch5</a></li>
<li><a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a></li>
</ul>
<p></br></p>
<p><a name="tree_series"></a></p>
<h3>BST系列文章</h3>
<p><a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html">Binary Search Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html">Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html">Binary Search Tree: Sort(排序)、Delete(刪除資料)</a>  </p>
<p>回到目錄：</p>
<p><a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">目錄：演算法與資料結構</a></p>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/binary-search-tree.html">Binary Search Tree</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>