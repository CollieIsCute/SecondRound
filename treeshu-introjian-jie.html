<!DOCTYPE html>
<html lang="zh-hant">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">


        <title>Tree(樹): Intro(簡介)</title>

            <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Full Atom Feed" />
            <link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" type="application/atom+xml" rel="alternate" title="Second Round Categories Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="http://alrightchiu.github.io/SecondRound/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="http://alrightchiu.github.io/SecondRound/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="C++" />
        <meta name="tags" contents="Intro" />


	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Second Round">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html">
	<meta property="og:title" content="Tree(樹): Intro(簡介)">
	<meta property="og:description" content="">
	<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/">
	<meta property="article:published_time" content="2015-12-19 20:27:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://alrightchiu.github.io/SecondRound/">Second Round</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                        <li><a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a></li>
                        <li><a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a></li>

                            <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html">About</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('http://alrightchiu.github.io/SecondRound/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Tree(樹): Intro(簡介)</h1>
                        <span class="meta">Posted by
                                <a href="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">Chiu CC</a>
                             on 12 19, 2015
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p></br></p>
<h3>先備知識與注意事項</h3>
<p>若熟悉Linked List(連結串列)將會更容易理解樹：Linked list是一維的線性結構(不是往前、就是往後)，樹(與Graph)則推廣成多維的結構。  </p>
<p><center>
<img alt="linkedlist" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f1.png?raw=true" /></p>
<p><strong>圖一：A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。<br />
連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。</strong><br />
</center>   </p>
<p>關於Linked list，請參考：</p>
<ul>
<li><a href="http://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html">Linked List：Intro(簡介)</a>  </li>
<li><a href="http://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html">Linked List：新增資料、刪除資料、反轉</a>   </li>
</ul>
<p><a href="https://www.youtube.com/watch?v=u1ZB_rGFyeU">OK Go</a>.  </p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#example">隨處可見的Tree(樹)</a>  </li>
<li><a href="#essence">那麼，樹最根本的特徵是什麼？</a>   </li>
<li><a href="#tree_not_tree">還有哪些結構是樹？</a>  </li>
<li><a href="#element">用以描述一棵樹的元素</a>  </li>
<li><a href="#definition">樹的定義</a>  </li>
<li><a href="#code">程式碼</a>  </li>
<li><a href="#set">集合關係</a>  </li>
<li><a href="#ref">參考資料</a></li>
<li><a href="#tree_series">Tree系列文章</a></li>
</ul>
<p></br></p>
<p><a name="example"></a></p>
<h2>隨處可見的Tree(樹)</h2>
<p><strong>Tree(樹)</strong>是用以描述具有<strong>階層結構</strong>(hierarchical structure)的問題的首選，階層結構意味著明確的先後次序，例如，若要印出ABC三個字母的所有排列組合(permutation)，直覺反射的圖像會是：  </p>
<p><center><br />
<img alt="fig1.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f2.png?raw=true" />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img alt="fig1.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f3.png?raw=true" />  </p>
<p><strong>圖二：ABC字母排列組合。<br />
視R為樹根(root)，每一個選擇狀態視為node，此即為樹的結構。</strong>
</center>
</br></p>
<p>圖二的邏輯為：從起點(R)開始，先決定第一個字母，再依序決定第二、第三個字母，並且，在每一次選擇字母時，可能有不止一個可供選擇的字母。最後一共走出六條路徑，得到六種排列組合，而且這六種排列方式只能經由一種唯一的選擇方式(唯一的路徑)產生。<br />
若將起點(R)視為樹根(root)，每一個字母選擇的狀態(例如：A、C、BC、CAB)都視為一個node，這樣的結構便能夠視為一棵樹。  </p>
<p>另外如一本書的目錄、族譜、企業的職位關係，甚至是更廣義的「從家門口為起點尋找方圓一公里以內的便利商店」都能夠建立出樹的模型。  </p>
<p></br></p>
<p><a name="essence"></a></p>
<h2>那麼，樹最根本的特徵是什麼？</h2>
<p>以族譜為例，若定義包龍星是宋世傑的爸爸，那麼包龍星就絕對不能同時又是宋世傑的兒子。  </p>
<p>圖三以node與edge描述此關係，並定義箭頭是從父指向子，則：</p>
<ul>
<li>包龍星指向宋世傑的箭頭表示包為父、宋為子；</li>
<li>宋世傑指向包龍星的箭頭表示宋為父、包為子；</li>
</ul>
<p>後者的箭頭即違反了最初「包龍星是宋世傑的爸爸」的命題，此即稱為cycle，也就是著名的「雞生蛋」與「蛋生雞」。  </p>
<p><center>
<img alt="cycle" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f4.png?raw=true" />  </p>
<p><strong>圖三：包龍星若是宋世傑的parent(父)，又同時為其child(子)，即形成cycle。</strong>
</center></p>
<p>而樹的最根本特徵就是：<strong>在樹的結構裡，只有一個root(樹根)，並且不存在cycle</strong>。<br />
此特徵將衍生出另外兩項等價的性質：</p>
<ol>
<li>在樹中若要從root尋找特定node，一定只存在一條路徑(path)。  </li>
<li>每個node只會有一個parent。</li>
</ol>
<p></br> </p>
<p><a name="tree_not_tree"></a> </p>
<h2>還有哪些結構是樹？</h2>
<p>下列四種結構中，a、b可以視為樹，而c、d則否：</p>
<p><center>
<img alt="fig2.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f5.png?raw=true" />  </p>
<p><strong>圖三.a：若樹的node只有指向left subtree(左子樹)與right subtree(右子樹)時，又稱為Binary Tree(二元樹)。</strong><br />
</br> 
<img alt="fig2.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f6.png?raw=true" />  </p>
<p><strong>圖三.b：若樹退化成Linked list(連結串列)，仍滿足樹的定義。</strong>  <br />
</br>
<img alt="fig2.c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f7.png?raw=true" />  </p>
<p><strong>圖三.c：在F出現cycle；以及，D有兩個parent node。</strong><br />
</br>
<img alt="fig2.d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f8.png?raw=true" />  </p>
<p><strong>圖三.d：一棵樹只能有一個root(樹根)。此圖像又稱為Forest(樹林)。</strong>
</center></p>
<p></br></p>
<p><a name="element"></a></p>
<h2>用以描述一棵樹的元素</h2>
<p>配合圖四，以下將介紹在樹中常見的元素。  </p>
<p>針對<strong>node / vertex</strong>：  </p>
<ul>
<li><strong>degree(分歧度)</strong>：一個node擁有的subtree(子樹)的個數。<ul>
<li>圖四，A的degree為<span class="math">\(3\)</span>，F的degree為<span class="math">\(2\)</span>，N的degree為<span class="math">\(0\)</span>。  </li>
</ul>
</li>
<li><strong>root(樹根)</strong>：樹中最上層的node，也是唯一一個其parent為<strong>NULL</strong>的node。<ul>
<li>圖四，A即為root。</li>
</ul>
</li>
<li><strong>leaf</strong>：沒有child/subtree的node稱為leaf node。<ul>
<li>圖四，G、H、J、K、L、M、N皆為leaf node。</li>
</ul>
</li>
<li><strong>external node</strong>：沒有child的node。因此，leaf node與external node同義。</li>
<li><strong>internal node</strong>：至少有一個child的node，稱為internal node。<ul>
<li>圖四，A、B、C、D、E、F、I皆為internal node。</li>
</ul>
</li>
</ul>
<p><center>
<img alt="fig3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f9.png?raw=true" />   </p>
<p><strong>圖四：這是一棵普通的樹。</strong><br />
</center>  </p>
<p>針對<strong>樹</strong>：</p>
<ul>
<li><strong>parent</strong> &lt;--&gt; <strong>child</strong>：以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。<ul>
<li>圖四，A為C的parent，C為A的child；E為K的parent，K為E的child。</li>
</ul>
</li>
<li><strong>siblings</strong>：擁有相同parent的node們，互相稱兄道弟。<ul>
<li>圖四，B、C、D共同的parent為A，那麼B、C、D即為彼此的<strong>sibling</strong>。</li>
</ul>
</li>
<li><strong>descendant(子嗣)</strong>：圖四中，站在A，所有能夠以「parent指向child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。<ul>
<li>站在F，能夠以「parent指向child」找到的node有L、M，則稱L、M為F的descendant。</li>
</ul>
</li>
<li><strong>ancestor(祖先)</strong>：圖四中，站在K，所有能夠以「尋找parent」的方式找到的node，皆稱為K的ancestor，因此，E、B、A皆為K的ancestor。</li>
<li><strong>path(路徑)</strong>：由descendant與ancestor關係連結成的edge，例如A-B-E-K、A-C-F-N。</li>
<li><strong>level</strong>：定義root的level為<span class="math">\(1\)</span>，其餘node的level為其parent的level加一。</li>
<li><strong>height of node</strong>：某一node與其最長path上之descendant leaf node之間的edge數。<ul>
<li>例如，F的height為<span class="math">\(1\)</span>，D的height為<span class="math">\(2\)</span>，leaf node的height為<span class="math">\(0\)</span>。</li>
</ul>
</li>
<li><strong>height of tree</strong>：樹的height即為root的height。<ul>
<li>圖四中，樹的height為A的height，等於<span class="math">\(3\)</span>。</li>
</ul>
</li>
<li><strong>depth</strong>：某一node與root之間的edge數。<ul>
<li>例如，F的depth為<span class="math">\(2\)</span>，L的depth為<span class="math">\(3\)</span>。  </li>
</ul>
</li>
</ul>
<p>可以想像的是，在樹中的<strong>traversal</strong>(尋訪)之時間複雜度(time complexity)會與<strong>height</strong>(樹高)有關。</p>
<p></br></p>
<p><a name="definition"></a></p>
<h2>定義</h2>
<p>以下列出兩種互相等價的Tree(樹)的定義：  </p>
<p>A. <strong>Tree(樹)</strong>是由一個或多個節點所組成的有限集合，並且滿足：  </p>
<ol>
<li>存在且只有一個稱為<code>root</code>(樹根)的節點；</li>
<li>其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：<span class="math">\(T_1、...、T_n\)</span>，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的<strong>subtree(子樹)</strong>。</li>
</ol>
<p>B. <strong>Tree(樹)</strong>是由一個或多個nodes/vertices以及edge所組成，而且沒有cycle的集合(set)。  </p>
<p>在圖三(d)中，曾出現<strong>Forest(樹林)</strong>，其定義也很直觀：</p>
<ul>
<li>由<span class="math">\(n\geq 0\)</span>棵彼此互斥(disjoint)的Tree(樹)所形成的集合(Set)，即稱為Forest(樹林)。</li>
</ul>
<p><center>
<img alt="forest" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f10.png?raw=true" />  </p>
<p><strong>圖五：Forest(樹林)由多個Tree(樹)所組成，可以用來表示互斥集合(disjoint set)。</strong>
</center></p>
<p></br></p>
<p><a name="code"></a></p>
<h2>程式碼</h2>
<p>實務上，要以程式碼實作一棵樹，常用的手法為：先以<code>class TreeNode</code>(或是<code>struct</code>)定義出每顆node能夠指向多少subtree、攜帶哪些資料形態，再以另一個<code>class Tree</code>表示整棵樹，並以<code>root</code>作為樹的存取點：</p>
<div class="highlight"><pre><span class="c1">// C++ code</span>
<span class="k">class</span> <span class="nc">Tree</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">{</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftchild</span><span class="p">;</span>   <span class="c1">// 以下表示每一個node有四個pointer指向child</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightchild</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">whatever</span><span class="p">;</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">works</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">data1</span><span class="p">;</span>             <span class="c1">// node所攜帶的information</span>
    <span class="kt">double</span> <span class="n">data2</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Tree</span><span class="p">;</span>     <span class="c1">// 讓class Tree能夠存取TreeNode的private data</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Tree</span><span class="p">{</span>
    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>        <span class="c1">// 以root作為存取整棵樹的起點</span>
<span class="p">};</span>
</pre></div>


<p></br></p>
<p><a name="set"></a></p>
<h2>集合關係</h2>
<p>Tree(樹)位居承先啟後的重要戰略位置，圖六是常見的與Tree有關的資料結構之集合關係圖：</p>
<p><center>
<img alt="fig4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/f11.png?raw=true" />  </p>
<p><strong>圖六：與Tree(樹)相關的資料結構之集合關係。</strong>
</center></p>
<p>本篇介紹的Tree(樹)並沒有限制child/ subtree的個數，理論上可以有多到超過記憶體空間的child node。  </p>
<p>然而在實務上，較常使用每個node至多只有兩個child的樹，稱為<a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"><strong>Binary Tree</strong>(二元樹)</a>。  </p>
<p>從Binary Tree再增加「鍵值(<strong>Key</strong>)大小規則」，即得到<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"><strong>Binary Search Tree</strong>(BST，二元搜尋樹)</a>。  </p>
<p>以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的<strong>height</strong>，以減短搜尋時間，這種樹稱為<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"><strong>Red Black Tree</strong>(RBT，紅黑樹)</a>。  </p>
<ul>
<li>常見的平衡樹(balanced tree)還有：<strong>AVL tree</strong>、<strong>2-3-4 tree</strong>、<strong>Splay tree</strong>等等，請參考：<a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Wikipedia：Self-balancing binary search tree</a></li>
</ul>
<p>另一個方向，若打破「不能存在cycle」的限制，則從Tree推廣至<a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"><strong>圖(Graph)</strong></a>。  </p>
<p>在接下來的文章將先以縮小集合的方向依序介紹：Binary Tree、BST、RBT，再進入Graph(圖)這個更複雜的主題。</p>
<p></br></p>
<hr />
<p><a name="ref"></a></p>
<h3>參考資料：</h3>
<ul>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++, Ch5</a></li>
<li><a href="http://program-lover.blogspot.tw/2008/12/tree.html">Infinite Loop：【演算】樹 - Tree</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">Wikipedia：Tree(data structure)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Wikipedia：Self-balancing binary search tree</a></li>
</ul>
<p></br></p>
<p><a name="tree_series"></a></p>
<h2>Tree系列文章</h2>
<p><a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html">Tree(樹): Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html">Binary Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">Binary Tree: 建立一棵Binary Tree</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html">Binary Search Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html">Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html">Binary Search Tree: Sort(排序)、Delete(刪除資料)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html">Red Black Tree: Intro(簡介)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html">Red Black Tree: Rotation(旋轉)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Insert(新增資料)與Fixup(修正)</a><br />
<a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Delete(刪除資料)與Fixup(修正)</a></p>
<p>回到目錄：</p>
<p><a href="http://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">目錄：演算法與資料結構</a></p>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </article>

        <div class="tags">
            <p>tags: <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>, <a href="http://alrightchiu.github.io/SecondRound/tag/intro.html">Intro</a>, </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://github.com/alrightchiu">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog powered by <a href="http://getpelican.com">Pelican</a>,
    which takes great advantage of <a href="http://python.org">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="http://alrightchiu.github.io/SecondRound/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="http://alrightchiu.github.io/SecondRound/theme/js/clean-blog.min.js"></script>

</body>

</html>